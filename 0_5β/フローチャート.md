１　初期設定

初期設定はmain process 関数で初期ポジションをbookから読み込むようにした。
load_all_positions関数でbookを読み込んで全てのポジションを予め変数としてメモリに保存しておく。
棋譜変数は空

２　メインループ開始
子ポジションを生成するために親positionのデータをmain_process関数からget_children関数に渡す。

３　子ポジションの生成と変数の更新

get_children関数で、bookのlink情報やleaf情報を元に子ポジションを生成するための処理。
get_children関数ではまず使うlinkやleafを選定する処理を行う。フラグ管理でまだ未使用となっているlinkやleafを選ぶ処理を行う。
その後、get_children関数からprocess_position関数にポジション情報と選んだリンクやリーフの情報を渡す。
process_position関数からcreate_position_data関数にデータを渡す。
create_position_data関数で棋譜変数を更新するためにconvert_move_to_str関数を呼び出す。
convert_move_to_str関数内で、bookに書かれているリンク情報やリーフ情報のmoveの値を棋譜に変換。
棋譜変数の末尾にこの棋譜の2文字を追加する形で更新。create_position_data関数に返す。
その後、create_position_data関数内からflip_stones 関数とshift関数を呼び出す。
flip_stones 関数で石を置いて反転、shift関数で調整。これで子ポジションのデータが完成するので新しい関数から子ポジションの盤面データをデータ受け取り元に渡す。この場合はprocess_position関数になる。process position関数に子ポジションのデータが返ってきたら一旦今の盤面情報を変数に保存しておく。

４　子ポジションの評価

子ポジションを read_position 関数でbookから読み込むのだが、bookの盤面登録の仕様で工夫が必要になる。
その前にやるべきことがある。
まず、親ポジションのVisitedフラグの更新を今のうちにやっておく。このタイミングで行うのが最善である。
まず親ポジションをNormalize関数に渡す。
まず、normalize_position関数とその子関数たちを使って、盤面の対称変換、回転変換で作った8盤面の中からビット値が最小値となる盤面を選ぶ。
その盤面がbookに登録されている盤面となっている。リンクやリーフも同様なのでNormalize move関数に渡して正規化を行う。
正規化されたポジションデータが実際にメモリに保存されている、load_all_positions関数によって既に変数に登録されたものである。
変数とは即ちbook positionsであるので、クラスマネージャーにあるupdate_book_position関数で
直接book positionを更新することによりVisitedフラグを永久保存する。
その後、変数にとっておいた子ポジションのデータをとってくる。このとき変数の中身は消さないこと。
子ポジションのデータをNormalized関数で正規化する。
正規化された子ポジションの盤面データをread_position 関数に渡す。一致する盤面ををread_position 関数で探す。
無事子ポジションのデータが見つかったらそのデータがread_position 関数からprocess_position関数に返ってくる。
その後盤面を、保存していた変数を使って正規化前に戻す。さらにdemonalize moveを使ってmove値も元に戻す。でないと今後の棋譜や盤面生成のループができない。
それが終わったら処理をmain_process 関数に戻す。

５　不一致の評価と不一致の場合の処理
これはモードによって何の不一致を判定するかが変化する。判定はjudge_mismatch関数を読みだして行う。
予め使ったmoveをget children関数から受け取っておく。使うのはmoveの評価値のみであるので正規化については気にしなくてよい。
不一致の場合の処理はmismatch_process関数が行う。データなどは予めmain_process 関数から受け取っておく。
判定に必要な各種値はmodeに応じて必要な分だけ計算する。計算補助としてcalculate_parent_eval関数が定義されているのでそれも利用する。

* Mode 1:
   * 処理の分岐　子ポジションのリーフの評価値と子ポジションのリンクの評価値のうち最大のものを比較　リーフの評価値のほうが大きい場合に不一致と判定
　 * 出力 子ポジションのリーフまでの棋譜を出力

* Mode 2:
   * 処理の分岐: main_process 関数にある子ポジションの評価値と子ポジションのリンクやリーフの評価値のうち最大のものの評価を比較
   * 出力分岐その１大きい場合は子ポジションの評価値より大きい評価値を持つ全ての子ポジションのリンクやリーフを洗い出し、それらの棋譜を出力する。

   * 出力分岐その2　小さい場合はその判定に使った子ポジションの手までの棋譜を出力する
* Mode 3 
   * 処理の分岐: main_process 関数にある親ポジションの(子ポジションに到達するために打った）リンクもしくはリーフの評価値と、子ポジションの評価値の反転を比較
   * 出力分岐その１大きい場合は親ポジションの(子ポジションに到達するために打った）リンクもしくはリーフの評価値に－1をかけたものより大きい評価値を持つ全ての子ポジションのリンクやリーフを洗い出し、それらの棋譜を出力する。
   * 出力分岐その2　小さい場合はその判定に使った子ポジションの手までの棋譜を出力する

* Mode 4 
   * 処理の分岐: main_process 関数にある親ポジションの(子ポジションに到達するために打った）リンクもしくはリーフの評価値と、子ポジションのリンクやリーフの評価値のうち最大のものの評価値の反転を比較
   * 出力分岐その１大きい場合は親ポジションの(子ポジションに到達するために打った）リンクもしくはリーフの評価値に－1をかけたものより大きい評価値を持つ全ての子ポジションのリンクやリーフを洗い出し、それらの棋譜を出力する。
   * 出力分岐その2　小さい場合はその判定に使った子ポジションの手までの棋譜を出力する

実際に欲しいデータは子positionの棋譜データである。現在kifu関数に入っている値は親positionのものである。
棋譜の出力は、出力するmoveごとに処理を行う。そのmove値を数値からconvert_move_to_str関数で文字列に変換する。
それが終わったら今のkifu値+変換された文字列を出力ファイルに出力する。
これで目的の子ポジションの棋譜が手に入り、これをそのまま学習できるようになる。

その後一致でも不一致でも処理を続行。


６　子ポジションを新しい親ポジションにして探索続行

親ポジションのデータを廃棄し、(ここで廃棄されるので親ポジションは正規化したまま放置でよかった）
子ポジションとして渡されているデータを新しい親ポジションとする処理を行う。
前の過程で既に正規化前に戻っている盤面情報とリンクやリーフ情報は完全に一致し、ループできる状態になる。
その後２　メインループ開始からループを再開する。

７　新しい親ポジションの生成　

リンクの最後、リーフが親ポジションになるまで到達したら、その後のデータはないため新しい親ポジションが生成できなくなる。
あるいは合流により全てのリンクやリーフの手にvisited=Trueのフラグが付いていることがある。その場合も処理を続行できない。
この時に新しい親ポジションを生成するために処理を行う必要がある。

４　子ポジションの評価の実行途中で、read_position 関数でbook全体から（予め読み込まれている)positionを探したが、該当positionが見つからなかった場合（リーフを読み込んだ場合のケース）
（この場合main_process 関数に、子positionのデータではなく、見つからなかったというデータを渡す。）
元のリーフデータにフラグを立てた後、get_children関数の処理を中止、main_processの処理を中止して新しい親positionを受け取れる状態に戻した後、チャート２からチャート５までのループを一旦中止し、recreate_parent_position 関数を呼びだす。
全てのリンクやリーフの手にvisited=Trueのフラグが付いていた場合も同様に処理を中断し、recreate_parent_position 関数を呼びだす。

☆
まず、undo_flip_stones関数を呼び出し、予めflip_stones 関数でスタックして置いた盤面スタックから盤面を引き出す形でundo処理を行う。
棋譜変数の値から棋譜を一手分だけ削除する。(ここで言う一手とは、F5みたいな組の文字列データ）
このあとの処理のために正規化前の盤面情報を変数に保存しておく。
その後ポジションの正規化を行うためにポジションデータをnormalize_position関数に渡して、
正規化されたポジションをnormalize_positionから返してもらう。
その後、正規化されたポジションをread_position関数に渡して、read_position関数で、bookから該当盤面のpositionデータを読み込む。
positionデータが読み込めたら、まだVisitedフラグが立っていないリンクやリーフの手がどれか一つでもあるかチェックする。

一つでも存在した場合、このポジションデータを新しい親ポジションとするのだが、
新しい親ポジションは正規化前のものとするため、盤面は情報は予め保存しておいたデータから元に戻す処理を行う。
リンクとリーフ情報はdemonalize move関数を使って元に戻す。これらを組み合わせて新しい親ポジションを作成する。
この親ポジションは完全なものであるため、２　メインループ開始からループを再開する。
全てのリンクとリーフの手にVisitedフラグが立っていた場合は☆マークの処理に戻る。
すなわちもう一手棋譜を削除し、正規化、読み込みを行って新しいポジションを作り、もう一度チェックするというループを行う。

8　ループの終了
このようにしていくといつかbookに存在するすべてのリンクやリーフの手にVisitedフラグが立つ。
ループの途中でkifu変数が空になった場合、もう新しいポジションは作れない。
この瞬間、新しい親ポジションを作成するループを終え、プログラム全体を終了する。



各関数の機能

最初にインクルード　構造体、unorderd map用の定義、グローバル変数の宣言を行う。
boost版ではvectorがboost small vectorになっていて大幅にメモリ効率がよくなっている。

main():　関数
各ファイルのアドレスの指定
コンフィグ読み込み関数の起動　変なmodeが指定されていたらプログラムを落とす
load_all_positions関数の起動
デバッグログ出力レベルの設定
main_process関数の起動

class PositionManager:　
時間の計測やこの後のポジションマネージャー用の宣言。
関数全体で必要な各種変数やフラグの設定

debug_log関数
デバッグログ出力機能。デバッグログレベルで出力を変えられるように実装
現在のデバッグログレベルを記入するのはこっちの関数
auto_adjust_log_level　機能の搭載

init_debug_log関数　log_level_to_string 関数
BOM付UTF-8への整形、デバッグログの出力の先頭に現在の時刻を記入

read_config関数
コンフィグから設定を読み込んでくるための関数
mode設定、デバッグログ設定など。大文字小文字無視で書けるようにしてある。
auto_adjust機能は詳しくチェックしたいところのデバッグログをWarningに変更して、そこから詳細情報を得るための使い方を想定している。
あまりにも開発中用の機能。現在の段階で使うためにはコードの直接編集が必要

load_all_positions関数
bookから予めデータを読み込んでおくための関数
ファイルオープン、データのフォーマットの指定、データサイズの計算ヘッダー部分をスキップ
各種ポジション情報やリンクやリーフのデータを読み込んでいくのだが、move値のみはリトルエンディアンの関係で180度回転処理が必要になるので
その処理はrotate_move_180(move)関数に委託。
ここで予めリストに各ポジションにおいてVisitedフラグも仕込んでおく。
各データはなるべく効率的になるように設定。いらないものはその場で廃棄。
盤面evalはint16からint8へ変換する処理を実装。メモリ効率が上昇
全てのポジションデータが読み終わったら終了。
boost版ではメモリマップドファイルとboost版のunorderd mapが実装されており読み込みが2倍くらい早い
その後の処理もboost版のunorderd mapのほうが高速
デバッグ用に各種情報も出力

count_collisions関数
ハッシュ関数の衝突頻度を測定するために存在。
衝突を今のハッシュ関数より小さくしたいがなかなかうまくいかない
メモリテーブルが小さいため。flat hash mapを使うと衝突は減るがメモリ使用量が爆増するのでやめた経歴がある。

format_position(position)関数
盤面の情報を16進数でフォーマットするための関数。その他bool値を正しくTrue Falseで出力。
デバッグログ出力用に各所で使用される。


main_process関数　実質メイン関数
main関数から直接起動される
初期盤面設定を読み込んで親positionとする
子ポジションを生成するために親positionのデータをget_children関数に渡す
完成した子ポジションデータをget_children関数から返してもらう
各modeに応じて不一致判定をjudge_mismatch関数で行う
不一致だった場合のみの動作として、その情報をmismatch_process関数に渡し、不一致棋譜を出力してもらう
その後子ポジションのデータを新しく親ポジションとする
その後スタック変数を操作し、次に起動するべき関数の管理を行う。（自身or recreate_parent_position関数)
ループの最後に1ループに所要した時間の記録を行う
最後のコードはエラーの場合の処理

judge_mismatch関数
不一致判定のための関数
各modeに応じて必要な計算を行い、不一致を判定してmismatchだったかどうかのbool値を返す
必要な場合calculate_parent_eval関数も利用

calculate_parent_eval関数
親ポジションのリンクやリーフのうち最大の評価値を持つものを調べて返すだけの関数
コードの重複を避けるため独立関数として定義

mismatch_process関数　
不一致だった場合に出力を行うための関数
どのモードでも欲しいのは子ポジションまでの棋譜である。
棋譜データを数値からconvert_move_to_str関数で文字列に変換する
それが終わったら今のkifu値+変換された文字列を出力ファイルに出力する
リンクやリーフが盤面評価値より大きい場合は該当するリンクやリーフ全て
小さい場合はその手のリンクやリーフを出力するようにしている
出力テキストファイルをBOM付で作る機能もある

get_children関数
bookのlink情報やleaf情報を元に子ポジションを生成するための前処理
get_children関数ではまず使うlinkやleafを選定する処理を行う。フラグ管理でまだ未使用(Visited=Falese)となっているlinkやleafを選ぶ処理を行う。
リンクが優先される。
その後、get_children関数からprocess_position関数にポジション情報と選んだリンクやリーフの情報を渡す
もし、すべてのリンクやリーフが使用済み(VIsited=True)となっていた場合は代わりの処置として
recreate_parent_position関数へ処理を移行させる
この際リーフの初期値(リーフなし)やnoneは無視される

process_position関数
子ポジションを生成するための関数
process_position関数からcreate_position_data関数にデータを渡す。この後の処理で、process_position関数に子ポジションの盤面データが返ってくる
その子ポジションは一旦変数に保存。その後、親ポジションをnormalize_position関数に渡して正規化
そのデータをread_position 関数に渡し、予めメモリに保存してあるbook全体から探す
これは絶対見つかるはずなので見つかったらメモリに保存してあるbookを直接更新。親ポジションの該当手のVisitedをTrueに更新。
この際move値もnormalize_move関数を呼び出して正規化しておく必要がある。
変数から子ポジションのデータを拾いそれをnormalize_position関数に渡す。normalize_position関数から正規化されたポジションが返ってくる
そのデータをread_position 関数に渡し、予めメモリに保存してあるbook全体から探す
データが見つかった場合、リンクデータとリーフデータを変数にコピー、フラグを更新
その後、main_processにデータを渡す
もしデータが見つからなかった場合は代わりの処置として、recreate_parent_position関数へ処理を移行させる

create_position_data関数
process_position関数から受け取ったデータで実際に子ポジションを作る処理
convert_move_to_str関数をまず呼び出し受け取ったデータの一部である、リンクやリーフのmove値を文字列棋譜データに変換してもらう。

convert_move_to_str関数
リンクやリーフのmove値を文字列棋譜データに変換する関数。
変換表があるのでそれに基づいて変換。
A1=0 B1=1 ...H1=7 A2=8... A8=56... H8=63 Pass=64 None=65

flip_stones関数
石をひっくり返すための関数。ビットボードで実装している。コードは短いけどやってることは分かりにくい。O(48)の実装

shift関数
flip_line関数
flip_all_directions関数
石をひっくり返すための補助関数　とてもやっていることがわかりにくい。
constexpr uint64_t direction_mask　石ひっくり返し用の変数

undo_flip_stones関数
石をひっくり返した時に盤面をスタックに保存している。そのスタックを引っ張り出してきて盤面を1手戻すための関数

normalize_position関数
bookに実際に登録されている盤面は正規化されたものである。
正規化とは、8つの回転、対称移動の盤面値を生成し、その中から16bitの盤面bitboard値が最小のものを選ぶこと。この盤面がbookに登録されている。
このあとの逆変換処理のための変換関数記憶処理も行う

denormalize_move関数
move値を正規化前に戻す処理が必要になることがある。そのための関数。
予め直前に使った変換を記憶していて、その逆の変換を行う。

normalize_move関数
normalize_position関数のmove値版
denormalize_move関数の逆

rotate_90(x)
rotate_180(x)
rotate_270(x)
flip_vertical(x)
flip_horizontal(x)
flip_diag_a1h8(x)
flip_diag_a8h1(x)
rotate_move_90(move)
rotate_move_180(move)
rotate_move_270(move)
flip_move_vertical(move)
flip_move_horizontal(move)
flip_move_diag_a1h8(move)
flip_move_diag_a8h1(move)
各方向への回転変換関数
transformations 
reverse_transformations
ビットボード変換用辞書

read_position関数
データを実際にメモリに保存したbookから読み込む関数

update_book_position関数
Visitedのbool値を更新するための関数

recreate_parent_position関数
process_position関数かget_children関数で子ポジションを生成できなかったときに呼び出される関数
まず棋譜を1手戻し、undo_flip_stones関数を呼び出して盤面を1手戻す
一旦この盤面を変数に保存しておく
その後normalize_position関数を呼び出し、盤面を正規化。その盤面をbookから探す
そしてリンクやリーフのVisitedフラグをチェック
一つでもFalseのリンクやリーフがあれば、ポジション情報を全て正規化前のものに戻しそれを新たな親ポジションとし、main_process関数に渡す
盤面はあらかじめ保存しておいた変数から戻し、リンクやリーフはdemonalize move関数を使う。
もしすべてのリンクやリーフのVisitedフラグがTrueなら棋譜変数を更新し、再度recreate_parent_position関数の処理の頭に戻りもう一度1手盤面を戻すところからやる

そうこうしていって最終的に棋譜変数が空になったらプログラム終了。


read_specified_positions関数
mode5で動作。ほぼデバッグ用。
load all posiitons関数で読んできたbookから、テキストファイルに指定されたmy positionsとopponent positionの値の組から該当するpositionを読み込んできてデータをdebuglogに出力する。
変なことが起きたらエラーを出力して落とす。
